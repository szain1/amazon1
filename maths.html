<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Linear Programming Graphical Solver</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        .input-section {
            flex: 1;
            min-width: 300px;
        }
        .graph-section {
            flex: 1;
            min-width: 300px;
        }
        textarea, input, select, button {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            box-sizing: border-box;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background-color: #45a049;
        }
        .constraint {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
        }
        .constraint input {
            flex: 1;
        }
        .constraint select {
            width: auto;
        }
        .remove-constraint {
            width: auto;
            background-color: #f44336;
            padding: 5px 10px;
        }
        .remove-constraint:hover {
            background-color: #d32f2f;
        }
        .result {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f8f8;
            border-radius: 5px;
        }
        canvas {
            max-width: 100%;
            border: 1px solid #ddd;
            background-color: white;
        }
        .example-btn {
            background-color: #2196F3;
            margin-bottom: 20px;
        }
        .example-btn:hover {
            background-color: #0b7dda;
        }
    </style>
</head>
<body>
    <h1>Linear Programming Graphical Solver</h1>
    
    <button class="example-btn" onclick="loadExample()">Load Example Problem</button>
    
    <div class="container">
        <div class="input-section">
            <h2>Problem Input</h2>
            
            <label for="problemType">Problem Type:</label>
            <select id="problemType">
                <option value="max">Maximization</option>
                <option value="min">Minimization</option>
            </select>
            
            <label for="objective">Objective Function (e.g., 3x + 4y):</label>
            <input type="text" id="objective" placeholder="Example: 5x + 3y (Maximize profit)">
            
            <h3>Constraints</h3>
            <div id="constraintsContainer">
                <div class="constraint">
                    <input type="text" placeholder="Example: 2x + y" class="constraint-expr">
                    <select class="constraint-type">
                        <option value="<=">≤</option>
                        <option value=">=">≥</option>
                        <option value="=">=</option>
                    </select>
                    <input type="number" placeholder="10" class="constraint-value">
                    <button type="button" class="remove-constraint" onclick="removeConstraint(this)">×</button>
                </div>
                <div class="constraint">
                    <input type="text" placeholder="Example: x + 2y" class="constraint-expr">
                    <select class="constraint-type">
                        <option value="<=">≤</option>
                        <option value=">=" selected>≥</option>
                        <option value="=">=</option>
                    </select>
                    <input type="number" placeholder="8" class="constraint-value">
                    <button type="button" class="remove-constraint" onclick="removeConstraint(this)">×</button>
                </div>
            </div>
            
            <button type="button" onclick="addConstraint()">Add Constraint</button>
            <button type="button" onclick="solveProblem()">Solve Problem</button>
            
            <div class="result" id="result">
                <p>Enter your linear programming problem and click "Solve Problem" to see the solution.</p>
                <p>Example format: "3x + 2y" (without quotes)</p>
            </div>
        </div>
        
        <div class="graph-section">
            <h2>Graphical Solution</h2>
            <canvas id="graphCanvas"></canvas>
            <div id="graphInfo"></div>
        </div>
    </div>

    <script>
        // Initialize Chart.js
        const ctx = document.getElementById('graphCanvas').getContext('2d');
        let chart = new Chart(ctx, {
            type: 'scatter',
            data: {
                datasets: []
            },
            options: {
                responsive: true,
                scales: {
                    x: {
                        type: 'linear',
                        position: 'center',
                        min: 0,
                        max: 10,
                        title: {
                            display: true,
                            text: 'x-axis'
                        }
                    },
                    y: {
                        type: 'linear',
                        position: 'center',
                        min: 0,
                        max: 10,
                        title: {
                            display: true,
                            text: 'y-axis'
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'bottom'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `(${context.parsed.x.toFixed(2)}, ${context.parsed.y.toFixed(2)})`;
                            }
                        }
                    }
                }
            }
        });

        // Load example problem
        function loadExample() {
            document.getElementById('problemType').value = 'max';
            document.getElementById('objective').value = '5x + 3y';
            
            const constraints = document.querySelectorAll('.constraint');
            constraints[0].querySelector('.constraint-expr').value = '2x + y';
            constraints[0].querySelector('.constraint-type').value = '<=';
            constraints[0].querySelector('.constraint-value').value = '10';
            
            constraints[1].querySelector('.constraint-expr').value = 'x + 2y';
            constraints[1].querySelector('.constraint-type').value = '<=';
            constraints[1].querySelector('.constraint-value').value = '8';
            
            // Add a third constraint if it exists, otherwise create it
            if (constraints.length > 2) {
                constraints[2].querySelector('.constraint-expr').value = 'x';
                constraints[2].querySelector('.constraint-type').value = '>=';
                constraints[2].querySelector('.constraint-value').value = '0';
            } else {
                addConstraint();
                const newConstraint = document.querySelector('.constraint:last-child');
                newConstraint.querySelector('.constraint-expr').value = 'x';
                newConstraint.querySelector('.constraint-type').value = '>=';
                newConstraint.querySelector('.constraint-value').value = '0';
            }
            
            // Add a fourth constraint for y >= 0
            if (constraints.length > 3) {
                constraints[3].querySelector('.constraint-expr').value = 'y';
                constraints[3].querySelector('.constraint-type').value = '>=';
                constraints[3].querySelector('.constraint-value').value = '0';
            } else {
                addConstraint();
                const newConstraint = document.querySelector('.constraint:last-child');
                newConstraint.querySelector('.constraint-expr').value = 'y';
                newConstraint.querySelector('.constraint-type').value = '>=';
                newConstraint.querySelector('.constraint-value').value = '0';
            }
            
            solveProblem();
        }

        // Add a new constraint
        function addConstraint() {
            const container = document.getElementById('constraintsContainer');
            const newConstraint = document.createElement('div');
            newConstraint.className = 'constraint';
            newConstraint.innerHTML = `
                <input type="text" placeholder="Example: x + y" class="constraint-expr">
                <select class="constraint-type">
                    <option value="<=">≤</option>
                    <option value=">=">≥</option>
                    <option value="=">=</option>
                </select>
                <input type="number" placeholder="10" class="constraint-value">
                <button type="button" class="remove-constraint" onclick="removeConstraint(this)">×</button>
            `;
            container.appendChild(newConstraint);
        }

        // Remove a constraint
        function removeConstraint(button) {
            const container = document.getElementById('constraintsContainer');
            if (container.children.length > 1) {
                button.parentElement.remove();
            } else {
                alert("You need at least one constraint.");
            }
        }

        // Parse a linear expression
        function parseExpression(expr, variables) {
            if (!expr) throw new Error("Empty expression");
            
            // Normalize the expression
            expr = expr.replace(/\s+/g, '').toLowerCase();
            
            // Initialize coefficients
            const coeffs = {};
            variables.forEach(v => coeffs[v] = 0);
            
            // Split into terms
            const terms = expr.split(/(?=[+-])/);
            
            for (let term of terms) {
                if (term === '') continue;
                
                // Handle the sign
                let sign = 1;
                if (term.startsWith('-')) {
                    sign = -1;
                    term = term.substring(1);
                } else if (term.startsWith('+')) {
                    term = term.substring(1);
                }
                
                // Find the variable in the term
                let varMatch = term.match(/[a-z]/);
                if (!varMatch) continue; // constant term (not handling for now)
                
                const varName = varMatch[0];
                if (!variables.includes(varName)) {
                    throw new Error(`Unexpected variable: ${varName}. Only x and y are supported.`);
                }
                
                // Get the coefficient
                let coeffPart = term.split(varName)[0];
                let coeff = 1;
                
                if (coeffPart !== '') {
                    coeff = parseFloat(coeffPart);
                    if (isNaN(coeff)) {
                        throw new Error(`Invalid coefficient in term: ${term}`);
                    }
                }
                
                coeffs[varName] += sign * coeff;
            }
            
            return coeffs;
        }

        // Find intersection points of two constraints
        function findIntersection(constraint1, constraint2, variables) {
            const a1 = constraint1.coeffs[variables[0]];
            const b1 = constraint1.coeffs[variables[1]];
            const c1 = constraint1.value;
            
            const a2 = constraint2.coeffs[variables[0]];
            const b2 = constraint2.coeffs[variables[1]];
            const c2 = constraint2.value;
            
            const denominator = a1 * b2 - a2 * b1;
            
            if (Math.abs(denominator) < 1e-10) {
                return null; // parallel lines
            }
            
            const x = (b2 * c1 - b1 * c2) / denominator;
            const y = (a1 * c2 - a2 * c1) / denominator;
            
            return { x, y };
        }

        // Check if a point satisfies all constraints
        function isFeasible(point, constraints) {
            for (const constraint of constraints) {
                const lhs = constraint.coeffs.x * point.x + constraint.coeffs.y * point.y;
                let satisfied = false;
                
                if (constraint.type === '<=' && lhs <= constraint.value + 1e-10) {
                    satisfied = true;
                } else if (constraint.type === '>=' && lhs >= constraint.value - 1e-10) {
                    satisfied = true;
                } else if (constraint.type === '=' && Math.abs(lhs - constraint.value) < 1e-10) {
                    satisfied = true;
                }
                
                if (!satisfied) {
                    return false;
                }
            }
            return true;
        }

        // Solve the linear programming problem
        function solveProblem() {
            try {
                // Clear previous results
                document.getElementById('graphInfo').innerHTML = '';
                
                // Get problem type
                const problemType = document.getElementById('problemType').value;
                
                // Parse objective function
                const objectiveExpr = document.getElementById('objective').value;
                if (!objectiveExpr) throw new Error("Please enter an objective function");
                
                const variables = ['x', 'y']; // We'll assume 2 variables for graphical method
                const objectiveCoeffs = parseExpression(objectiveExpr, variables);
                
                // Parse constraints
                const constraints = [];
                const constraintElements = document.querySelectorAll('.constraint');
                
                for (const element of constraintElements) {
                    const expr = element.querySelector('.constraint-expr').value;
                    const type = element.querySelector('.constraint-type').value;
                    const value = parseFloat(element.querySelector('.constraint-value').value);
                    
                    if (!expr) throw new Error("Please enter all constraint expressions");
                    if (isNaN(value)) throw new Error("Please enter valid numbers for constraint values");
                    
                    const coeffs = parseExpression(expr, variables);
                    constraints.push({ coeffs, type, value });
                }
                
                // Find all intersection points
                const intersections = [];
                
                // Add intersections between constraints
                for (let i = 0; i < constraints.length; i++) {
                    for (let j = i + 1; j < constraints.length; j++) {
                        const intersection = findIntersection(constraints[i], constraints[j], variables);
                        if (intersection) {
                            intersections.push(intersection);
                        }
                    }
                }
                
                // Add intersections with axes
                for (const constraint of constraints) {
                    // Intersection with x-axis (y=0)
                    if (Math.abs(constraint.coeffs.x) > 1e-10) {
                        const x = constraint.value / constraint.coeffs.x;
                        intersections.push({ x, y: 0 });
                    }
                    
                    // Intersection with y-axis (x=0)
                    if (Math.abs(constraint.coeffs.y) > 1e-10) {
                        const y = constraint.value / constraint.coeffs.y;
                        intersections.push({ x: 0, y });
                    }
                }
                
                // Filter feasible points
                const feasiblePoints = intersections.filter(point => 
                    point.x >= -1e-10 && point.y >= -1e-10 && isFeasible(point, constraints)
                );
                
                if (feasiblePoints.length === 0) {
                    throw new Error("No feasible solution exists (empty feasible region)");
                }
                
                // Evaluate objective function at each feasible point
                feasiblePoints.forEach(point => {
                    point.objValue = objectiveCoeffs.x * point.x + objectiveCoeffs.y * point.y;
                });
                
                // Find optimal solution
                let optimalPoint;
                if (problemType === 'max') {
                    optimalPoint = feasiblePoints.reduce((max, point) => 
                        point.objValue > max.objValue ? point : max
                    );
                } else {
                    optimalPoint = feasiblePoints.reduce((min, point) => 
                        point.objValue < min.objValue ? point : min
                    );
                }
                
                // Display results
                const resultDiv = document.getElementById('result');
                resultDiv.innerHTML = `
                    <h3>Solution</h3>
                    <p><strong>Optimal Point:</strong> (${optimalPoint.x.toFixed(2)}, ${optimalPoint.y.toFixed(2)})</p>
                    <p><strong>Optimal Value:</strong> ${optimalPoint.objValue.toFixed(2)}</p>
                    <p><strong>Number of Feasible Points:</strong> ${feasiblePoints.length}</p>
                `;
                
                // Update the graph
                updateGraph(constraints, feasiblePoints, optimalPoint, variables, objectiveCoeffs, problemType);
                
            } catch (error) {
                document.getElementById('result').innerHTML = `
                    <h3>Error</h3>
                    <p style="color: red;">${error.message}</p>
                    <p>Please check your input and try again.</p>
                `;
                console.error(error);
            }
        }

        // Update the graph with constraints and solution
        function updateGraph(constraints, feasiblePoints, optimalPoint, variables, objectiveCoeffs, problemType) {
            // Clear previous datasets
            chart.data.datasets = [];
            
            // Determine graph bounds
            let maxX = 5, maxY = 5;
            let minX = 0, minY = 0;
            
            // Plot constraints
            constraints.forEach((constraint, i) => {
                const color = getColor(i);
                
                // For each constraint, plot the line
                const linePoints = [];
                
                // Find two points to draw the line
                // Point 1: x=0
                if (Math.abs(constraint.coeffs.y) > 1e-10) {
                    const y1 = constraint.value / constraint.coeffs.y;
                    linePoints.push({ x: 0, y: y1 });
                    maxY = Math.max(maxY, y1 * 1.2);
                }
                
                // Point 2: y=0
                if (Math.abs(constraint.coeffs.x) > 1e-10) {
                    const x2 = constraint.value / constraint.coeffs.x;
                    linePoints.push({ x: x2, y: 0 });
                    maxX = Math.max(maxX, x2 * 1.2);
                }
                
                // If we don't have two points, find another point
                if (linePoints.length < 2 && Math.abs(constraint.coeffs.x) > 1e-10) {
                    const x = maxX;
                    const y = (constraint.value - constraint.coeffs.x * x) / constraint.coeffs.y;
                    linePoints.push({ x, y });
                    maxY = Math.max(maxY, y * 1.2);
                }
                
                // Sort points by x for better line drawing
                linePoints.sort((a, b) => a.x - b.x);
                
                // Add constraint line
                chart.data.datasets.push({
                    label: `Constraint ${i+1}: ${constraint.coeffs.x}${variables[0]} + ${constraint.coeffs.y}${variables[1]} ${constraint.type} ${constraint.value}`,
                    data: linePoints,
                    type: 'line',
                    borderColor: color,
                    backgroundColor: color,
                    borderWidth: 2,
                    fill: false,
                    showLine: true,
                    pointRadius: 0
                });
            });
            
            // Plot feasible region (as a polygon)
            if (feasiblePoints.length >= 3) {
                // Sort points clockwise for proper polygon drawing
                const center = { x: 0, y: 0 };
                feasiblePoints.forEach(p => {
                    center.x += p.x;
                    center.y += p.y;
                });
                center.x /= feasiblePoints.length;
                center.y /= feasiblePoints.length;
                
                const sortedPoints = [...feasiblePoints].sort((a, b) => {
                    return Math.atan2(a.y - center.y, a.x - center.x) - 
                           Math.atan2(b.y - center.y, b.x - center.x);
                });
                
                chart.data.datasets.push({
                    label: 'Feasible Region',
                    data: sortedPoints,
                    backgroundColor: 'rgba(75, 192, 192, 0.2)',
                    borderColor: 'rgba(75, 192, 192, 0.8)',
                    borderWidth: 1,
                    pointRadius: 0,
                    type: 'line',
                    fill: true,
                    showLine: true
                });
            }
            
            // Plot feasible points
            chart.data.datasets.push({
                label: 'Feasible Points',
                data: feasiblePoints,
                backgroundColor: 'rgba(54, 162, 235, 0.8)',
                borderColor: 'rgba(54, 162, 235, 1)',
                borderWidth: 1,
                pointRadius: 5
            });
            
            // Plot optimal point
            chart.data.datasets.push({
                label: 'Optimal Solution',
                data: [optimalPoint],
                backgroundColor: 'rgba(255, 99, 132, 0.8)',
                borderColor: 'rgba(255, 99, 132, 1)',
                borderWidth: 2,
                pointRadius: 8
            });
            
            // Plot objective function line (for visualization)
            const objLinePoints = [];
            if (Math.abs(objectiveCoeffs.y) > 1e-10) {
                const y1 = optimalPoint.objValue / objectiveCoeffs.y;
                objLinePoints.push({ x: 0, y: y1 });
            }
            if (Math.abs(objectiveCoeffs.x) > 1e-10) {
                const x2 = optimalPoint.objValue / objectiveCoeffs.x;
                objLinePoints.push({ x: x2, y: 0 });
            }
            if (objLinePoints.length < 2 && Math.abs(objectiveCoeffs.x) > 1e-10) {
                const x = maxX;
                const y = (optimalPoint.objValue - objectiveCoeffs.x * x) / objectiveCoeffs.y;
                objLinePoints.push({ x, y });
            }
            
            if (objLinePoints.length >= 2) {
                chart.data.datasets.push({
                    label: `Objective (${problemType} ${optimalPoint.objValue.toFixed(2)})`,
                    data: objLinePoints,
                    type: 'line',
                    borderColor: 'rgba(153, 102, 255, 0.7)',
                    backgroundColor: 'rgba(153, 102, 255, 0.7)',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    fill: false,
                    showLine: true,
                    pointRadius: 0
                });
            }
            
            // Update chart scales
            chart.options.scales.x.min = minX;
            chart.options.scales.x.max = maxX;
            chart.options.scales.y.min = minY;
            chart.options.scales.y.max = maxY;
            
            chart.update();
            
            // Display graph information
            const graphInfo = document.getElementById('graphInfo');
            graphInfo.innerHTML = `
                <p><strong>Graph Dimensions:</strong> x: 0 to ${maxX.toFixed(2)}, y: 0 to ${maxY.toFixed(2)}</p>
            `;
        }

        // Get a color for constraint lines
        function getColor(index) {
            const colors = [
                'rgba(255, 99, 132, 1)',
                'rgba(54, 162, 235, 1)',
                'rgba(255, 206, 86, 1)',
                'rgba(75, 192, 192, 1)',
                'rgba(153, 102, 255, 1)',
                'rgba(255, 159, 64, 1)'
            ];
            return colors[index % colors.length];
        }
    </script>
</body>
</html>